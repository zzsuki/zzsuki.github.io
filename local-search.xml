<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>固件分析</title>
    <link href="/2021/07/05/iot-intro/"/>
    <url>/2021/07/05/iot-intro/</url>
    
    <content type="html"><![CDATA[<h1 id="固件分析"><a href="#固件分析" class="headerlink" title="固件分析"></a>固件分析</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="物联网设备安全问题"><a href="#物联网设备安全问题" class="headerlink" title="物联网设备安全问题"></a>物联网设备安全问题</h3><p>物联网设备在研发过程中，往往存在如下问题：</p><ol><li>物联网设备在设计与开发时，因为网络环境特性不像传统服务器那样，更多关注功能实现而忽略安全性考虑，往往存在漏洞，并且缺乏后期安全检查</li><li>由于设备硬件资源限制，比如车机系统等，很难进行完整的安全防护策略实施，导致漏洞更容易被攻击者利用。而且这个问题由于物联网设备对移动性和体积的限制，基本上很难完全克服这个问题</li></ol><p>因为上述原因，对物联网设备的安全管理主要是通过设计时的安全考虑和开发中的安全检测来实现。而安全检测的方式与传统的软件漏挖技术也相对一致，主要分<strong>静态分析</strong>、<strong>动态模糊测试</strong>、*<em>同源性分析</em>：</p><ol><li>静态分析：对设备固件进行提取和解析，通过建立特定漏洞类型的分析规则(如检测脚本)，从而使用静态程序分析技术挖掘漏洞</li><li>动态分析：对真实设备或通过模拟固件运行实现的仿真系统进行相关的安全测试来发现漏洞(即运行状态下的检测)</li><li>同源性分析：由于软件开发中会应用到大量的第三方开源工具，因此也意味着第三方工具的漏洞往往也就是软件本身的漏洞，同源性分析就是将这些开源工具与软件关联起来进行分析</li></ol><h3 id="物联网设备漏挖的难点"><a href="#物联网设备漏挖的难点" class="headerlink" title="物联网设备漏挖的难点"></a>物联网设备漏挖的难点</h3><h4 id="通用漏挖技术"><a href="#通用漏挖技术" class="headerlink" title="通用漏挖技术"></a>通用漏挖技术</h4><p>通用漏挖技术一般分为基于源代码的漏挖和基于二进制的漏挖：</p><ol><li>基于源码：一般为静态分析的形式，建立特定检测规则，采用数据流分析、污点分析、符号执行等技术完成对应规则的验证，从而实现漏挖</li><li>基于二进制：二进制文件一般可执行，所以在静态基础上又可以进行动态和动静结合的策略；静态二进制分析一般先将二进制代码转换为汇编语言，或者进一步转换为某种统一的中间语言，之后再通过基于模式的漏洞分析或二进制代码比对实现静态漏挖；动态二进制方案则使用fuzz技术进行实施；动静结合一般用静态结果辅助动态测试</li></ol><h4 id="物联网漏挖的难点"><a href="#物联网漏挖的难点" class="headerlink" title="物联网漏挖的难点"></a>物联网漏挖的难点</h4><ol><li>硬件资源受限：通用二进制分析技术需要在运行程序的外部进行实时监控完成分析，而物联网设备存储资源，计算资源等往往受限，无法很好的部署相关的分析工具，动态分析也就往往难以实施</li><li>硬件架构各异：当前主流的架构arm、x86、mips等架构，在物联网设备中都时长出现，各家都可能有所不同，因此无法通过通用的CPU指令汇编的静态分析来实现物联网漏挖；而且一般物联网设备的IO设备也都复杂多样，进行动态分析时也很难适配</li><li>反开源特性：通用软件与功能，往往总能找到一些开源的代码或二进制文件进行分析，而物联网设备大多为高度集成的专用设备，一来固件很难提取，二来大部分厂商都会把固件当作严格保密的控制对象，只有极少数固件可以拿到源码进行分析。因此源码分析技术就很难适用于物联网设备的漏挖，同时高度集成也包含了软件层的高度定制，数据结构和架构也与通用软件有所区别，因此基于二进制的静态分析技术往往也难以施展</li></ol><h3 id="物联网漏挖的突破点"><a href="#物联网漏挖的突破点" class="headerlink" title="物联网漏挖的突破点"></a>物联网漏挖的突破点</h3><ol><li>平台交互频繁：物联网设备往往需要进行联网，与终端、云服务等进行频繁数据交互，通信行为和对象越多，同时也意味着可攻击的范围和路径更多，所以可以想办法利用信息交互的过程，对新的攻击面进行测试</li><li>组件代码的复用：由于物联网设备在研发中，一般不会对外开放源码，同时也为了节省研发成本，所以往往会使用大量的三方库，对应三方库的漏洞也就广泛存在于物联网设备中。因此基于二进制比对的静态分析技术就可以通过不同层次(控制流、程序块、指令集)的差异性来关联分析发现同源漏洞</li><li>漏洞类型的相对固定：通用软件中的漏洞一般包含内存破坏类(栈溢出、堆溢出、空指针应用、二次释放等)、输入验证类(命令注入等)、配置错误类等。漏洞的位置从低到高可能存在于内核、驱动、用户态程序中。固件系统本质上也是一个小系统，因此传统平台的检测方法也适用于与物联网设备的固件与程序</li></ol><h2 id="物联网漏挖技术-固件分析"><a href="#物联网漏挖技术-固件分析" class="headerlink" title="物联网漏挖技术 - 固件分析"></a>物联网漏挖技术 - 固件分析</h2><h3 id="技术要点-方向"><a href="#技术要点-方向" class="headerlink" title="技术要点/方向"></a>技术要点/方向</h3><p>简单的说，目前决定的调研方向主要分为三个方向，如图：<br><img src="../images/firmwareAnalysis.png" alt="firmwareAnalysis"></p><p>针对三个不同的方向上的关键节点，做了不同程度的调研</p><h4 id="固件提取"><a href="#固件提取" class="headerlink" title="固件提取"></a>固件提取</h4><p>固件提取使用binwalk，不做多余的描述，基本上和一期这部分一致；目前看到的各个工具中，提取/解压这个步骤基本都绕不开binwalk</p><h4 id="固件模拟运行"><a href="#固件模拟运行" class="headerlink" title="固件模拟运行"></a>固件模拟运行</h4><h5 id="firmadyne"><a href="#firmadyne" class="headerlink" title="firmadyne"></a>firmadyne</h5><p>Firmadyne是一款自动化和可裁剪的嵌入式Linux系统固件分析框架。它支持系统固件逆向QEMU嵌入式系统模拟执行。使用它模拟路由器固件执行路由器，然后可以基于模拟环境进行路由器漏洞挖掘、渗透攻防。</p><ol><li>运行逻辑：使用binwalk提取文件 -&gt; 检测是否存在文件系统 -&gt; 将提取出的系统打包成镜像 -&gt; 使用qemu运行固件</li><li>这个工具对路由器类的支持更好，官方说是有用来爬取主要厂商固件的爬虫，但是实际使用部署好以后数据库中没有其它的固件；目前从各个文献和文档看，应该是可以支持42个厂商的1W+固件</li><li>实际使用过程中，随便找的mips和arm架构的固件没运行成功，而且都是在初始化网卡的时候出的问题。查了很多文档尝试解决未果，最后看到个好像稍微靠谱的，但是很麻烦，需要改源码重新编译</li></ol><h4 id="静态文件检查"><a href="#静态文件检查" class="headerlink" title="静态文件检查"></a>静态文件检查</h4><h5 id="trommel"><a href="#trommel" class="headerlink" title="trommel"></a>trommel</h5><p>trommel可用于筛选嵌入式设备文件，以识别潜在的易受攻击的指标，支持一些检查：</p><ul><li>Secure Shell（SSH）密钥文件；</li><li>安全套接字层（SSL）密钥文件；</li><li>Internet协议（IP）地址；</li><li>统一资源定位器（URL）；</li><li>电子邮件地址；</li><li>shell 脚本；</li><li>Web 服务器二进制文件；</li><li>配置文件；</li><li>数据库文件；</li><li>特定的二进制文件（即 Dropbear，BusyBox 等）；</li><li>共享对象库文件；</li><li>Web 应用程序脚本变量；</li><li>Android 应用程序包（APK）文件权限</li></ul><p>使用深度不高，但是整体的表现像是做一些字符匹配，然后检查出关键内容什么状态，也很久没更新了，估计比较麻烦</p><h5 id="FACT-core"><a href="#FACT-core" class="headerlink" title="FACT_core"></a>FACT_core</h5><p><a href="https://fkie-cad.github.io/FACT_core/">FACT</a>全称Firmware Analysis and Comparison Tool，是一个拥有WEB端的自动化固件测试平台。设计宗旨是自动执行固件安全分析（路由器，物联网，UEFI，网络摄像头，无人驾驶飞机等等），平台使用Python-flask框架，采用模块化开发并支持插件接入，因此对于二次开发和优化应该相对算比较方便，目前在自己aliyun上搭建了一个<a href="http://47.240.100.196:5000/">FACT</a><br>FACT可以自动化完成固件解包任务并对其进行一定程度的固件分析：</p><ol><li>软件分析：包括使用的操作系统、存在哪些软件、使用了什么版本、有哪些伴随系统启动的服务、对应存在哪些漏洞</li><li>查找用户凭据</li><li>加密检测：私钥、证书、CPU架构</li><li>固件自动比对：将固件的新旧版本进行关联，可以识别已更改/相同的文件，识别更改的软件版本</li></ol><p>FACT_core主要的业务包括：unpacking、analysis与comparison，即解包、分析与比对；每一部分业务中具体又包含了任务调度器和插件集，每个调度器拥有的独立的线程(可以在system模块查看每个组件的线程池容量)</p><p>总的来说，FACT_core是目前调查过的工具里相对比较考虑的一个，其具有以下特征：</p><ol><li>内置的检查项多，web管理平台的执行逻辑其实和我们的固件分析很像，都是上传固件文件，然后勾选检查项(或使用默认策略)并进行对应的检查</li><li>个人感觉代码严谨，核心功能的工作流程设计很好，如果要二次开发的话会很方便</li><li>如果要运行的话很占内存，官方提供的最小要求也要4核心和8G内存，推荐的配置是16核64G（离谱）</li></ol><h4 id="同源性分析与相似度匹配"><a href="#同源性分析与相似度匹配" class="headerlink" title="同源性分析与相似度匹配"></a>同源性分析与相似度匹配</h4><p>这部分是实验室胡悦在做，主要针对<strong>可执行文件</strong>，采用的是相似度匹配的方式，最终表现为和库文件的相似度达到多少，然后再进一步验证漏洞，胡悦反映目前有个小demo，但是表现不尽人意；需要进一步评估可行性和确定给用户提供什么结果信息</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Rsyslog部署</title>
    <link href="/2021/07/05/rsyslog-deploy/"/>
    <url>/2021/07/05/rsyslog-deploy/</url>
    
    <content type="html"><![CDATA[<h1 id="Rsyslog部署"><a href="#Rsyslog部署" class="headerlink" title="Rsyslog部署"></a>Rsyslog部署</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>syslog是类unix操作系统常用的日志处理程序</p><p>rsyslog是Ubuntu系统默认的日志程序，官方的介绍</p><blockquote><p>RSYSLOG is the <strong>r</strong>ocket-fast <strong>sys</strong>tem for <strong>log</strong> processing.</p></blockquote><p>总体来说，部署分为服务端和客户端两部分</p><h2 id="配置项含义"><a href="#配置项含义" class="headerlink" title="配置项含义"></a>配置项含义</h2><h3 id="SELECTOR"><a href="#SELECTOR" class="headerlink" title="SELECTOR"></a>SELECTOR</h3><p>local0.*是选择器（selector），指定该条配置对哪些日志生效。由类型（facility）和等级（priority）组成</p><p>类型包括</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">kern     内核信息，首先通过 klogd 传递；<br>user     用户进程；<br>mail     邮件；<br>daemon   后台进程；<br>authpriv 授权信息；<br>syslog   系统日志；<br>lpr      打印信息；<br>news     新闻组信息；<br>uucp     由uucp生成的信息<br>cron     计划和任务信息。<br>mark     syslog 内部功能用于生成时间戳<br>local0----local7   自定义程序使用，例如使用 local5 作为 ssh 功能<br>*        通配符代表除了 mark 以外的所有功能<br></code></pre></td></tr></table></figure><p>等级包括</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">emerg 或 panic   该系统不可用（最紧急消息）<br>alert            需要立即被修改的条件（紧急消息）<br>crit             阻止某些工具或子系统功能实现的错误条件（重要消息）<br>err              阻止工具或某些子系统部分功能实现的错误条件（出错消息）<br>warning          预警信息（警告消息）<br>notice           具有重要性的普通条件（普通但重要的消息）<br>info             提供信息的消息（通知性消息）<br>debug            不包含函数条件或问题的其他信息（调试级-信息量最多）<br>none             没有重要级，通常用于排错（不记录任何日志消息）<br>*                所有级别，除了none<br></code></pre></td></tr></table></figure><p>可以指定多个选择器，用逗号分隔</p><h3 id="ACTION"><a href="#ACTION" class="headerlink" title="ACTION"></a>ACTION</h3><p>紧跟着选择器的是动作（action），表示对所选的日志进行的操作，例如可以存到文件、发送到终端、发送到远程服务器。</p><p>此处action使用了rsyslog的高级配置，除了指定IP和端口之外，可以指定重传次数，队列长度</p><h2 id="客户端部署"><a href="#客户端部署" class="headerlink" title="客户端部署"></a>客户端部署</h2><h3 id="linux部署"><a href="#linux部署" class="headerlink" title="linux部署"></a>linux部署</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>目前大多数发行版默认使用rsyslog进行日志记录，未安装时一般使用包管理工具可直接安装<br><code>yum install rsyslog -y</code><br><code>apt install -y rsyslog</code></p><p>主配置文件的位置是/etc/rsyslog.conf，可以将用户配置置于/etc/rsyslog.d文件夹内。</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>可以创建bga.conf用于传输日志到另一台服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">local0.*  action(type=&quot;omfwd&quot; target=&quot;192.168.1.120&quot; port=&quot;514&quot; protocol=&quot;tcp&quot;<br>                 action.resumeRetryCount=&quot;10&quot;<br>                 queue.type=&quot;linkedList&quot; queue.size=&quot;10000&quot;)<br><span class="hljs-meta">#</span><span class="bash"> local0.*为筛选器，格式为：<span class="hljs-string">&quot;日志类型.日志级别&quot;</span></span><br><span class="hljs-meta">#</span><span class="bash"> target为服务器的IP，protocol为采用的协议类型</span><br></code></pre></td></tr></table></figure><h2 id="服务器部署"><a href="#服务器部署" class="headerlink" title="服务器部署"></a>服务器部署</h2><h3 id="Linux部署"><a href="#Linux部署" class="headerlink" title="Linux部署"></a>Linux部署</h3><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><p>安装与服务器端安装一致即可</p><h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><p><code>edit /etc/rsyslog/rsyslog.conf</code>编辑配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">module(load=&quot;imtcp&quot;)  # 载入tcp模块，只能有一条<br>input(type=&quot;imtcp&quot; port=&quot;514&quot;)  # 启动监听端口，可以有多条，监听多个端口<br><br>local0.* /var/log/bga.log  # 将所有类型为local0的日志存储到/var/log/bga.log文件<br></code></pre></td></tr></table></figure><h3 id="Windows部署"><a href="#Windows部署" class="headerlink" title="Windows部署"></a>Windows部署</h3><h4 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h4><p>主流的软件包括KiwiSyslog和winsyslog等软件，其中kiwi有free trail，但现在获取需要2个工作日，很不方便</p><ol><li>下载文件<a href="https://onedrive.live.com/?authkey=!ABFrSuLKv_sDXO4&id=E4C9966B2424DB6F!1704&cid=E4C9966B2424DB6F">kiwisyslog-with-crack</a></li><li>下载完成后解压运行<code>Kiwi_Syslogd_8.3.7.setup.exe</code>进行安装</li><li>安装完成后进入<code>crack</code>目录，选择<code>Service</code>目录，打开managerc程序(exe文件)即完成服务的开启</li></ol><h4 id="防火墙配置"><a href="#防火墙配置" class="headerlink" title="防火墙配置"></a>防火墙配置</h4><ol><li>打开防火墙高级选项，添加入站规则，选择特定端口(端口设置为514或与服务器端口一致)，协议选择udp，并选择允许所有连接；重复上述步骤再添加一条tcp协议的入栈规则</li></ol><h4 id="syslog-server配置"><a href="#syslog-server配置" class="headerlink" title="syslog server配置"></a>syslog server配置</h4><ol><li>工具栏依次选择manage-&gt;Start the Syslogd service</li><li>工具栏依次选择File-&gt;Setup<ul><li>在Inputs中选择UDP设置UDP Port为514，Data encoding选择utf-8，Bind to address留空即可</li><li>选择TCP设置端口为514，编码同样选择utf-8</li></ul></li><li>依次点击apply-&gt;ok</li></ol><h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><p>python官方库是自带syslog支持的，可以直接用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> syslog<br><br>syslog.openlog(ident=<span class="hljs-string">&#x27;BGA&#x27;</span>, logoption=syslog.LOG_PID, facility=syslog.LOG_LOCAL0)<br>syslog.syslog(<span class="hljs-string">&quot;This is a test message.&quot;</span>)<br><br><span class="hljs-comment"># facilities: LOG_KERN, LOG_USER, LOG_MAIL, LOG_DAEMON, LOG_AUTH, LOG_LPR, LOG_NEWS, LOG_UUCP, LOG_CRON, LOG_SYSLOG, LOG_LOCAL0 to LOG_LOCAL7, and, if defined in &lt;syslog.h&gt;, LOG_AUTHPRIV.</span><br><br><span class="hljs-comment"># logoptions: LOG_PID, LOG_CONS, LOG_NDELAY, and, if defined in &lt;syslog.h&gt;, LOG_ODELAY, LOG_NOWAIT, and LOG_PERROR.</span><br></code></pre></td></tr></table></figure><p>查看服务器的/var/log/bga.log文件，新增了一条日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Mar 21 15:22:23 bolean BGA[4295]: This is a test message.<br></code></pre></td></tr></table></figure><p>日志格式是timestamp hostname ident[pid]：log message</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>软件授权</title>
    <link href="/2021/07/05/softwareAuth-intro/"/>
    <url>/2021/07/05/softwareAuth-intro/</url>
    
    <content type="html"><![CDATA[<h1 id="软件授权"><a href="#软件授权" class="headerlink" title="软件授权"></a>软件授权</h1><h2 id="背景概述"><a href="#背景概述" class="headerlink" title="背景概述"></a>背景概述</h2><p>传统软件授权方式常用的方式有基于授权码的授权与基于指纹的授权方式；其中基于指纹的授权方式，指纹来源一般选择捆绑主机的主板序列号以及其它部分硬件的序列号，即将授权与硬件进行捆绑，捆绑对象也不仅仅限于服务器自身的硬件，常用的还有usb等可移动的设备。<br>当前的环境下，虚拟化技术的使用日益增多，很多私有云等服务都基于虚拟化技术进行实施。在这种情况下，由于虚拟机往往与宿主机有着很多共同的硬件信息，而通过同一镜像在同一平台上安装的虚拟机，往往难以从硬件层面去做区分，导致传统的授权方式存在很多不便和漏洞。即使是信用良好的用户，也可能在授权后使用虚拟机的过程中无意通过一个已经完成授权的系统镜像复制出另一个虚拟机，从而使新的虚拟机也完成了授权。<br>因此，在虚拟化技术越来越广泛使用的今天，如何安全有效得完成软件授权管理，成为了一个新的问题</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><h3 id="授权模式整体转型"><a href="#授权模式整体转型" class="headerlink" title="授权模式整体转型"></a>授权模式整体转型</h3><p>为了应对上述的问题，有部分公司采取了授权模式转型的方式，将以前偏向于买断制的(seat-based and metric-based model)授权方式，逐步转换为偏向根据服务和交易量(transaction-based and consumption-based)进行授权的方式，以审计产品为例，这种方式的做法就是将审计的产品授权改为根据每月多少流量之类的进行收费，但是这种方式需要往往需要保持设备能保持在线，连接到管理平台，因此暂时不可取。<br>同时，使用这种模式代表着供销链上相关的部门和人员都得做出调整，销售模式会发生改变<br>于是，既不想破坏原有供销模式，也不想让产品被肆意复制的厂商，部分选择了基于虚拟机检测技术，直接禁止产品运行在虚拟机上，这显然走了另一个极端</p><h3 id="新的授权技术"><a href="#新的授权技术" class="headerlink" title="新的授权技术"></a>新的授权技术</h3><p>为了更好地解决虚拟化带来的授权问题，产生了如下几个方向的技术方法</p><h4 id="硬件钥匙-硬锁"><a href="#硬件钥匙-硬锁" class="headerlink" title="硬件钥匙(硬锁)"></a>硬件钥匙(硬锁)</h4><p>这种方式的解决方式，是将负责授权的信息存储在一个更可靠的位置，然后让软件的运行依赖于这个授权信息，通过这种方式，可以实现只有在软件能检测到对应信息(即对应硬件)时，才能正常运行。<br>这种方式的具体实施中，产生了常见的比如usb安全狗之类的产品，在usb设备上实现同一时刻只能被一台设备进行访问，这样无论对方的主机上有多少台虚拟机在运行，同一时刻内只有一台虚拟机可以访问硬锁并正常工作。  </p><p>由于其工作原理的原因，这种方式存在以下缺点：</p><ol><li>显而易见得，这种方式需要将硬件钥匙通过usb连接至虚拟机，而部分虚拟机管理平台对usb设备的支持不是很友好，有的甚至暂时不支持usb设备的使用，在这类平台上，这种方式就无法实施</li><li>部分厂商本身也不希望每次发货都要多发一个usb设备，这类厂商追求的是纯软件化的解决方案，这种解决方式也无法满足这类厂商</li></ol><h4 id="基于虚拟机检测的集中授权"><a href="#基于虚拟机检测的集中授权" class="headerlink" title="基于虚拟机检测的集中授权"></a>基于虚拟机检测的集中授权</h4><p>这种方式将授权管理系统强制性安装在一个真实的硬件设备里，客户在安装软件时可以随意安装至虚拟机或真实的主机，但是在安装时会对运行环境进行检测，如果运行环境是虚拟机，就会向授权管理系统发送请求，由授权管理系统决定是否同意安装</p><p>这种方式的特点包含：</p><ol><li>不需要每次发货都附一个usb设备</li><li>可以动态决定是否让虚拟机安装运行受控制的产品</li><li>需要保证客户的主机可以访问到授权管理系统，换言之就是需要在进行安装时保证虚拟机可以联网，连接到授权管理系统</li></ol><h4 id="虚拟机指纹识别"><a href="#虚拟机指纹识别" class="headerlink" title="虚拟机指纹识别"></a>虚拟机指纹识别</h4><p>上述方法其实还是在将虚拟机与真实的主机进行区分对待，理论上最优的解决方案，当然是实现将每个虚拟机与真实的主机实现同等对待并保证可以生成唯一的身份标识，这样就不用区分虚拟机和宿主机，也不用区分各个虚拟机，只需要将每个系统当作个体进行基于身份标识的管理。通过这种方式，可以摆脱硬件与网络的限制实现授权管理，并防止通过复制等方式进行扩增</p><p>这种方式包含以下特点：</p><ol><li>解决方案纯软件，整体更轻量，不需要在发货时提供usb等硬件设备，也不要求虚拟机要联通网络访问授权控制系统</li><li>如何将虚拟机进行唯一标识是这种方式的技术难点，纯粹的基于硬件肯定是不显示的</li></ol><h2 id="具体方案"><a href="#具体方案" class="headerlink" title="具体方案"></a>具体方案</h2><p>我司产品工作环境，默认不能连外网比较合适，因此不考虑授权管理系统的方案，那方向主要分为两类，即软锁与硬锁；基于这两个方案咨询了下对应厂商(包括淘宝上杂七杂八的一些商家)，之前提供safenet这个厂商的时候有提过感觉淘宝很多设备都绕不开这家，是因为这家公司是目前这个行业的标杆(以色列厂商，30年历史，懂的都懂)，然后也提到过关于虚拟机指纹的事，就这个问题也咨询过他们工程师()，他们的解决方案也主要分软锁和硬锁两类：</p><ol><li><p>软锁<br> 软锁可以实现之前提到的虚拟机指纹问题，单个软锁资源大概156RMB多，也就是每次发镜像需要额外花156RMB多买个软锁，但是软锁还有个成本是，目前市面上的这类产品，大多是使用(或者干脆说都是)safenet的技术实现，其中基本都是基于Sentinel HASP的厂商更多(淘宝上的各个商家其实就基本都是基于这个的二次开发或者经销商一样，核心技术就是这家safenet的)</p><p> 优点：</p><ol><li>轻量，不需要usb设备支持，看起来很美好</li><li>单个软件锁和硬件锁的价格一样，还方便</li><li>带了时钟锁，貌似很高大上，不过感觉咱们应该用不上</li><li>软锁后续需要切换成硬锁时官方宣称也可以无缝切换，不需要过多修改</li></ol><p> 缺点：</p><ol><li>这个软锁应该是做设备指纹的时候结合了硬件，也就是说如果宿主机的内存、CPU等信息发生更改，会导致授权失效，即这个镜像也成了非法的</li><li>safenet的政策，软锁虽然单价还能接受，但是首次使用需要使用5600RMB左右开通主锁的软锁功能(可以理解成用这个功能需要买个篮子，后边每次申请/购买的软锁都在这个篮子里管理)</li></ol></li><li><p>硬锁<br> 一般是与物理机进行绑定，更适合的场景是单一物理机上不限制复制镜像，但是不能跨物理机进行复制，safenet的硬锁绑定需要植入代码在安全内存中</p><p> 优点：</p><ol><li>安全性相对软锁更高，而且不需要一开始的功能开通的money，单个锁的基础功能也是156RMB</li></ol><p> 缺点：</p><ol><li>硬锁属于非特色服务，所以单价相对低(比如不需要买资源池)，但是高级功能，如时钟锁之类的也得单独买，以始终锁为例，单个硬锁要开通这个功能需要加302RMB</li><li>还是老问题，发货需要配个usb，再就是对方的虚拟机管理软件要支持虚拟机的usb拓展，同时对应虚拟机需要支持人体工学设备</li></ol></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="为什么不自己实现指纹检测？"><a href="#为什么不自己实现指纹检测？" class="headerlink" title="为什么不自己实现指纹检测？"></a>为什么不自己实现指纹检测？</h3><p>太难太复杂，根据套出来的话，safenet在这方面的做法，是通过多个维度的虚拟机相关信息生成摘要来实现的，已知的包含了镜像/虚拟机的uuid，对应的CPU物理id，磁盘序列号，MAC地址等，同时还会动态检查一些通用基本服务的运行，然后使用算法汇总运行状态，最终生成摘要完成设备的标识，也就是除了静态的一些检查，还采用了动态的运行检测。如果要自己做的话就很难。</p><h3 id="个人观点"><a href="#个人观点" class="headerlink" title="个人观点"></a>个人观点</h3><ol><li>目前看虚拟化这部分，是绕不开safenet的，而且这种安全产品也肯定不可能开源，所以暂时肯定找不到成本极低的方法，核心的虚拟机指纹识别部分应该也没法自己很快实现</li><li>基于上边的情况，那基本上还是要选货，就涉及到软硬锁和厂商的问题，软硬锁整体来看，软锁的方便特性很诱人，但是首次使用的授权费用决定，只适合长期使用这种镜像方式出货；如果是一次性的话肯定还是硬锁合算一些。上述价格是咨询上海澎凯的(感觉就是个经销商的样子)</li></ol><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>世文还找到了一家厂商，叫virbox，这家没有软锁解决方案，说是硬锁可以做到对镜像的控制，价格的话249元1只控制锁+1只用户锁，后续购买用户锁就可以了，标准版本88元一个；问了下原理好像是利用时钟检查。具体的没细问</p><hr><p>参考资料:</p><ol><li><p>safenet相关：</p><ol><li><a href="../pdfs/Platform-Virtualization-and-Software-Licensing.pdf">Platform-Virtualization-and-Software-Licensing</a></li><li><a href="../pdfs/%E8%BD%AF%E9%94%81%E4%BB%8B%E7%BB%8D.pdf">软锁介绍</a></li><li><a href="../pdfs/%E4%BA%A7%E5%93%81%E4%BB%8B%E7%BB%8D.pptx">软锁+硬锁介绍</a></li></ol></li><li><p><a href="../pdfs/DEFCON-18-Quynh-OS-Fingerprinting-VM.pdf">基于os的指纹识别</a></p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Suricata</title>
    <link href="/2021/07/05/suricata-intro/"/>
    <url>/2021/07/05/suricata-intro/</url>
    
    <content type="html"><![CDATA[<h1 id="Suricata"><a href="#Suricata" class="headerlink" title="Suricata"></a>Suricata</h1><h2 id="关于安全产品"><a href="#关于安全产品" class="headerlink" title="关于安全产品"></a>关于安全产品</h2><ul><li>IDS类<br>Intrusion Detection System的意思，即入侵检测系统，按照预设的安全策略，通过软硬件，对网络和系统的运行情况进行监视，尽可能多的发现各种攻击的企图、行为或结果，以保证网络和系统的机密性、完整性和可用性。IDS本身相当于监视器，主要负责“看到”入侵。实际部署中由于只负责检测，所以采用旁路部署为佳，这样不会阻断网络，主要负责报告和事后回溯监督</li><li>IPS类<br>Intrusion Prevention System的意思，即入侵防御系统，能够监视网络或网络设备的流量传输行为，在发现问题时能及时的采取预定的措施，中断、调整或隔离不正常或是有危害性的流量传输。实际工作时一般在线模式，即接入网络中，但表现为透明模式，即本身不对业务逻辑产生影响，因此肯定有多个网络端口，可以分析到数据包的内容，核心与IDS类一致，都要定义已知的攻击行为和模式，然后通过匹配的方式触发阻断</li><li>防火墙类<br>主要实现基本的包过滤策略，以前的防火墙大多工作在4层以下，实现策略上大多是关闭所有都通过的策略，只开放允许访问的策略，即造墙后有选择的凿洞</li><li>主动安全类<br>主动安全类的产品有很强的协议针对性，例如WAF专门负责HTTP协议的安全处理，DAF专门负责数据库SQL查询类的安全处理，这类产品基本都触碰到了应用层的内容，而对于不认识的业务访问采取的是强措施，即全部隔离</li></ul><p>其实总的来说安全类产品在做的事都是一致的，即先关闭所有的通路，然后开放想开放的。还有一些观点可以参考：</p><blockquote><ul><li>基础防火墙<br>传统防火墙是典型的主动安全类，关闭后再有选择的开启，但早期的防火墙不能检测到数据包的具体内容级别，因此如果针对高层协议进行攻击，遍很难处理</li><li>IPS<br>几乎所有的IPS产品都说可以检查数据包的内容，但有一个问题是，安全的原则反置了，将所有访问开放，然后阻断自己已知的攻击行为，非旁路部署又带来了性能的问题，移位置IPS永远不可能达到全面而细致的安全审计，除非砸钱怼设备或者本身流量就不大，也因为这个原因，大部分的IPS在实际运行中都形同虚设，一般只作为防DDOS的设备存在，因为IPS对未知的手段是无能为力的</li><li>主动安全类<br>工作在协议层，对协议进行彻底的分析和Proxy代理工作模式，同时结合对应用的访问流程进行分析，只通过已知的访问，阻断所有未知访问。</li></ul></blockquote><h2 id="Suricata原理"><a href="#Suricata原理" class="headerlink" title="Suricata原理"></a>Suricata原理</h2><p>Suricata是一个基于规则的入侵检测和防护引擎，利用外部开发的规则集进行网络流量的检测，可以处理多个千兆字节的流量，并提供电子邮件警报系统.</p><h3 id="Suricata主要特点"><a href="#Suricata主要特点" class="headerlink" title="Suricata主要特点"></a>Suricata主要特点</h3><ul><li>支持从nfqueue中读取流量</li><li>支持分析离线pcap文件和pcap文件方式存储流量数据</li><li>支持ipv6</li><li>支持pcap、af_packet、pfring、硬件卡抓包</li><li>多线程</li><li>支持内嵌lua脚本，以实现自定义检测和脚本输出</li><li>支持IP信用等级</li><li>支持文件还原</li><li>兼容snort</li><li>支持常见数据包解码：IPv4, IPv6, TCP, UDP, SCTP, ICMPv4, ICMPv6, GRE, Ethernet, PPP, PPPoE, Raw, SLL, VLAN, QINQ, MPLS, ERSPAN, VXLAN</li><li>支持常见应用层协议解码：HTTP, SSL, TLS, SMB, DCERPC, SMTP, FTP, SSH, DNS, Modbus, ENIP/CIP, DNP3, NFS, NTP, DHCP, TFTP, KRB5, IKEv2, SIP, SNMP, RDP</li></ul><h3 id="Suricata-基本架构"><a href="#Suricata-基本架构" class="headerlink" title="Suricata 基本架构"></a>Suricata 基本架构</h3><p><strong>运行模式</strong><br>包括三种运行模式，分别为single，workers，autofp。官方推荐性能最佳的运行模式为workers模式。</p><ul><li>single模式： 只有一个包处理线程，一般开发模式下使用</li><li>workers模式： 多个包处理线程，每个线程包含完整的处理逻辑</li><li>autofp模式： 多个包捕获线程和多个包处理线程，一般适用于nfqueue场景，从多个queue中消费流量来处理</li></ul><p><strong>四种线程模块</strong><br>包捕获：负责捕获数据包<br>解码：对数据包和应用层协议解码<br>检测：通过规则或者自定义脚本对数据包进行检测<br>输出：输出检测结果和常规协议的日志  </p><hr><h3 id="Suricata性能调优"><a href="#Suricata性能调优" class="headerlink" title="Suricata性能调优"></a>Suricata性能调优</h3><h4 id="抓包性能对比"><a href="#抓包性能对比" class="headerlink" title="抓包性能对比"></a>抓包性能对比</h4><p>硬件捕获&gt;pfring zc&gt;pfring&gt;af-packet&gt;pcap  </p><h4 id="调优"><a href="#调优" class="headerlink" title="调优"></a>调优</h4><ol><li>关闭网卡多队列功能<br>原因：一般使用流量镜像方式把流量镜像到服务器网卡，如果多队列的话，同一个tcp连接的数据有可能会被分散到不同的队列，由于时间的延迟可能导致有乱序可能。例如先收到了syn/ack，再收到syn，suricata会认为此流量无效而丢弃。如果做检测，则需要加缓冲和排序，代价较大</li><li>关闭网卡lro，grp特性<br>原因：lro/gro导致将各种较小的包合并成大的“超级包”，从而破坏suricata对tcp连接的跟踪  </li><li>使用pfring zc模式捕获包<br>原因：pfring+zero copy提升性能，但是zero copy需要网卡驱动支持；使用pfring模式抓包，只需要kernel支持即可。</li><li>调整配置文件中内存相关配置，调大flow.memcap,stream.memcap,stream.reassembly.memcap</li><li>使用workers模式运行</li><li>调整配置文件中max-pending-packets为8192</li><li>suricata编译需要支持luajit（用于替换原始lua），Hyperscan高性能正则库，PF_RING高性能包捕获库</li></ol><h4 id="Suricata-规则"><a href="#Suricata-规则" class="headerlink" title="Suricata 规则"></a>Suricata 规则</h4><ol><li>兼容snort规则</li><li>通过规则和内置的关键字实现对数据包的过滤和处理</li><li>Suricata4.x之后有自带的规则管理工具</li></ol><h4 id="Suricata-自定义检测"><a href="#Suricata-自定义检测" class="headerlink" title="Suricata 自定义检测"></a>Suricata 自定义检测</h4><p>支持通过lua脚本对数据包进行自定义检测，例如识别协议和异常流量</p><h4 id="Suricata-http-log自定义输出"><a href="#Suricata-http-log自定义输出" class="headerlink" title="Suricata http log自定义输出"></a>Suricata http log自定义输出</h4><p>支持通过lua脚本获取http协议request和response的相关信息，从而可以输出http协议中的所有数据，如header，request body，response body等</p><h4 id="Suricata-单进程同时监听两个网口"><a href="#Suricata-单进程同时监听两个网口" class="headerlink" title="Suricata 单进程同时监听两个网口"></a>Suricata 单进程同时监听两个网口</h4><p>通过修改suricata.yml文件实现，以pfring捕获方式为例，如下配置可同时捕获两个网口的流量配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">pfring:<br>  - interface: em2<br>    threads: auto<br>    cluster-id: 81<br>    cluster-type: cluster_flow<br>  - interface: em4<br>    threads: auto<br>    cluster-id: 82<br>    cluster-type: cluster_flow<br></code></pre></td></tr></table></figure><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>Suricata分析流量后，输出一般包括检测出的告警事件和解码后的所有应用协议的日志</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/07/05/IPSecVPN-Deploy/"/>
    <url>/2021/07/05/IPSecVPN-Deploy/</url>
    
    <content type="html"><![CDATA[<p>title: IPSecVPN服务搭建<br>date: 2021-07-05 02:50:09<br>tags:</p><h1 id="IPSecVPN服务搭建"><a href="#IPSecVPN服务搭建" class="headerlink" title="IPSecVPN服务搭建"></a>IPSecVPN服务搭建</h1><h2 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h2><h3 id="使用docker部署"><a href="#使用docker部署" class="headerlink" title="使用docker部署"></a>使用docker部署</h3><ol><li><p>部署docker</p></li><li><p>拉取自动化部署镜像：docker pull hwdsl2/ipsec-vpn-server</p></li><li><p>设置环境变量文件<code>.vpn.env</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 鉴别信息相关</span><br>VPN_IPSEC_PSK=your_ipsec_pre_shared_key<br>VPN_USER=your_vpn_username<br>VPN_PASSWORD=your_vpn_password<br><span class="hljs-meta">#</span><span class="bash"> 配置其它账号(存在多终端时建议分开配置账号)</span><br>VPN_ADDL_USERS=additional_username_1 additional_username_2<br>VPN_ADDL_PASSWORDS=additional_password_1 additional_password_2<br><span class="hljs-meta">#</span><span class="bash"> VPN服务器使用的nameserver，默认使用google的dns服务即8.8.8.8</span><br>VPN_DNS_SRV1=1.1.1.1<br>VPN_DNS_SRV2=1.0.0.1<br><span class="hljs-meta">#</span><span class="bash"> VPN服务器的FQDN值，会影响到IKEv2模式生成的证书(hostname -f 可查看FQDN)</span><br>VPN_DNS_NAME=vpn.example.com<br><span class="hljs-meta">#</span><span class="bash"> 指定client名称，类似一个tag一样，客户端配置以name为单位进行管理，默认vpnclient</span><br>VPN_CLIENT_NAME=your_client_name<br></code></pre></td></tr></table></figure></li><li><p>运行IPSec VPN服务器： <code>docker run --name ipsec-vpn-server --env-file .vpn.env --restart always -v ikev2-vpn-data:/etc/ipsec.d -p 500:500/udp -p 4500:4500/udp -d --privileged hwdsl2/ipsec-vpn-server</code></p><ul><li><p><code>-v</code>参数含义：自动创建volume挂载文件，使用-v时容器会自动启动IKEv2</p></li><li><p>支持的协议： IPsec/L2TP、IKEv2、IPsec/XAuth (“Cisco IPsec”)</p></li><li><p>关于privileged：如果考虑到安全，不希望给容器提供整体的超级权限；可以通过单独给容器设置必要的权限来控制(但可能导致一些未知的错误)，将<code>--privileged</code>改为：</p>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">--cap-add=NET_ADMIN \<br>--device=/dev/ppp \<br>--sysctl net.ipv4.ip_forward=1 \<br>--sysctl net.ipv4.conf.all.accept_redirects=0 \<br>--sysctl net.ipv4.conf.all.send_redirects=0 \<br>--sysctl net.ipv4.conf.all.rp_filter=0 \<br>--sysctl net.ipv4.conf.default.accept_redirects=0 \<br>--sysctl net.ipv4.conf.default.send_redirects=0 \<br>--sysctl net.ipv4.conf.default.rp_filter=0 \<br>--sysctl net.ipv4.conf.eth0.send_redirects=0 \<br>--sysctl net.ipv4.conf.eth0.rp_filter=0<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="服务配置常用"><a href="#服务配置常用" class="headerlink" title="服务配置常用"></a>服务配置常用</h3><ol><li>获取VPN登录信息： <code>docker logs ipsec-vpn-server</code></li><li>IKEv2配置：<ul><li>添加客户端：<code>docker exec -it ipsec-vpn-server ikev2.sh --addclient [client name]</code></li><li>导出已有客户端的配置：<code>docker exec -it ipsec-vpn-server ikev2.sh --exportclient [client name]</code></li><li>列出已有客户端的名称：<code>docker exec -it ipsec-vpn-server ikev2.sh --listclients</code>\</li><li>显示使用信息：<code>docker exec -it ipsec-vpn-server ikev2.sh -h</code></li><li>复制配置文件到宿主机（内容可用于客户端配置）：<code>docker cp ipsec-vpn-server:/etc/ipsec.d/vpnclient.p12 ./</code></li></ul></li></ol><h2 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h2><h3 id="IPsec-L2TP-VPN"><a href="#IPsec-L2TP-VPN" class="headerlink" title="IPsec/L2TP VPN"></a>IPsec/L2TP VPN</h3><h4 id="win10"><a href="#win10" class="headerlink" title="win10"></a>win10</h4><ul><li><p>图形界面操作：</p><ol><li>右键单击系统托盘中的无线/网络图标。</li><li>选择<strong>打开网络和共享中心</strong>。或者，如果你使用 Windows 10 版本 1709 或以上，选择<strong>打开”网络和Internet”设置</strong>，然后在打开的页面中单击<strong>网络和共享中心</strong>。</li><li>单击<strong>设置新的连接或网络</strong>。</li><li>选择<strong>连接到工作区</strong>，然后单击<strong>下一步</strong>。</li><li>单击**使用我的Internet连接 (VPN)**。</li><li>在<strong>Internet地址</strong>字段中输入<code>你的VPN 服务器 IP</code>。</li><li>在<strong>目标名称</strong>字段中输入任意内容。单击<strong>创建</strong>。</li><li>返回<strong>网络和共享中心</strong>。单击左侧的<strong>更改适配器设置</strong>。</li><li>右键单击新创建的 VPN 连接，并选择<strong>属性</strong>。</li><li>单击 <strong>安全</strong> 选项卡，从 <strong>VPN 类型</strong> 下拉菜单中选择 “使用 IPsec 的第 2 层隧道协议 (L2TP/IPSec)”。</li><li>单击 <strong>允许使用这些协议</strong>。选中 “质询握手身份验证协议 (CHAP)” 和 “Microsoft CHAP 版本 2 (MS-CHAP v2)” 复选框。</li><li>单击 <strong>高级设置</strong> 按钮。</li><li>单击 <strong>使用预共享密钥作身份验证</strong> 并在 <strong>密钥</strong> 字段中输入<code>你的 VPN IPsec PSK</code>。</li><li>单击 <strong>确定</strong> 关闭 <strong>高级设置</strong>。</li><li>单击 <strong>确定</strong> 保存 VPN 连接的详细信息。</li></ol></li><li><p>命令行执行：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmd"># 不保存命令行历史记录<br><span class="hljs-built_in">Set</span>-PSReadlineOption –HistorySaveStyle SaveNothing<br># 创建 VPN 连接<br>Add-VpnConnection -Name &#x27;My IPsec VPN&#x27; -ServerAddress &#x27;你的 VPN 服务器 IP&#x27; -L2tpPsk &#x27;你的 VPN IPsec PSK&#x27; -TunnelType L2tp -EncryptionLevel Required -AuthenticationMethod Chap,MSChapv2 -Force -RememberCredential -PassThr<br></code></pre></td></tr></table></figure></li><li><p><strong>注意</strong></p><ul><li>首次使用IPsec/L2TP 模式连接到 VPN 时，需要修改注册表以解决 VPN 服务器 和/或 客户端与 NAT （比如家用路由器）的兼容问题：<code>REG ADD HKLM\SYSTEM\CurrentControlSet\Services\PolicyAgent /v AssumeUDPEncapsulationContextOnSendRule /t REG_DWORD /d 0x2 /f</code></li><li>某些个别的 Windows 系统配置禁用了 IPsec 加密，此时也会导致连接失败。要重新启用它，可以运行以下命令并重启：<code>REG ADD HKLM\SYSTEM\CurrentControlSet\Services\RasMan\Parameters /v ProhibitIpSec /t REG_DWORD /d 0x0 /f</code></li></ul></li></ul><h4 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h4><ol><li>进入<strong>设置</strong> -&gt; <strong>通用</strong> -&gt; <strong>VPN</strong>。</li><li>单击 <strong>添加VPN配置</strong>…。</li><li>单击 <strong>类型</strong> 。选择 <strong>L2TP</strong> 并返回。</li><li>在 <strong>描述</strong> 字段中输入任意内容。</li><li>在 <strong>服务器</strong> 字段中输入<code>你的 VPN 服务器 IP</code>。</li><li>在 <strong>帐户</strong> 字段中输入<code>你的 VPN 用户名</code>。</li><li>在 <strong>密码</strong> 字段中输入<code>你的 VPN 密码</code>。</li><li>在 <strong>密钥</strong> 字段中输入<code>你的 VPN IPsec PSK</code>。</li><li>启用 <strong>发送所有流量</strong> 选项。</li><li>单击右上角的 <strong>完成</strong>。</li><li>启用 VPN 连接。</li></ol><h4 id="OS-X"><a href="#OS-X" class="headerlink" title="OS X"></a>OS X</h4><p>基础配置类似，在基础配置完成后需要单独注意的包括：</p><ul><li>单击 <strong>高级</strong> 按钮，并选中 <strong>通过VPN连接发送所有通信</strong> 复选框</li><li>单击 <strong>TCP/IP</strong> 选项卡，并在 <strong>配置IPv6</strong> 部分中选择 <strong>仅本地链接</strong></li></ul><h3 id="IKEv2-VPN（推荐方式）"><a href="#IKEv2-VPN（推荐方式）" class="headerlink" title="IKEv2 VPN（推荐方式）"></a>IKEv2 VPN（推荐方式）</h3><h4 id="Win10-GUI配置不推荐，-不如命令行快捷"><a href="#Win10-GUI配置不推荐，-不如命令行快捷" class="headerlink" title="Win10(GUI配置不推荐， 不如命令行快捷)"></a>Win10(GUI配置不推荐， 不如命令行快捷)</h4><ol><li><p>导入证书文件：<code>certutil -f -importpfx &quot;.p12文件的位置和名称&quot; NoExport</code>；导入过程中会要求输入证书密码，密码可通过上边的配置导出进行查看；这个步骤不论手工还是CLI实现，最终只要保证在导入证书后，将客户端证书放在 “个人 -&gt; 证书” 目录中，并且将 CA 证书放在 “受信任的根证书颁发机构 -&gt; 证书” 目录中</p></li><li><p>创建IKEv2 VPN连接,需要注意服务器地址必须和服务器端配置的一致，否则无法正常完成证书认证：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmd"># 创建 VPN 连接（将服务器地址换成你自己的值）<br>powershell -command &quot;Add-VpnConnection -ServerAddress &#x27;你的 VPN 服务器 IP（或者域名）&#x27; -Name &#x27;My IKEv2 VPN&#x27; -TunnelType IKEv2 -AuthenticationMethod MachineCertificate -EncryptionLevel Required -PassThru&quot;<br># 设置 IPsec 参数<br>powershell -command &quot;<span class="hljs-built_in">Set</span>-VpnConnectionIPsecConfiguration -ConnectionName &#x27;My IKEv2 VPN&#x27; -AuthenticationTransformConstants GCMAES128 -CipherTransformConstants GCMAES128 -EncryptionMethod AES256 -IntegrityCheckMethod SHA256 -PfsGroup None -DHGroup Group14 -PassThru -Force&quot;<br></code></pre></td></tr></table></figure></li><li><p>如果是手动创建的，则需要再配置下加密算法：<code>REG ADD HKLM\SYSTEM\CurrentControlSet\Services\RasMan\Parameters /v NegotiateDH2048_AES256 /t REG_DWORD /d 0x1 /f</code></p></li></ol><h4 id="OS-X-1"><a href="#OS-X-1" class="headerlink" title="OS X"></a>OS X</h4><p>直接将对应客户端的<code>.mobileconfig</code>文件传送至Mac，双击后按照提示导入描述文件，会自动配置一个VPN选项，然后连接即可，证书密码可通过导出对应客户端的配置信息查看</p><h4 id="iOS-1"><a href="#iOS-1" class="headerlink" title="iOS"></a>iOS</h4><p>与OS X一致</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://github.com/hwdsl2/docker-ipsec-vpn-server/blob/master/README-zh.md#%E9%85%8D%E7%BD%AE%E5%B9%B6%E4%BD%BF%E7%94%A8-ikev2-vpn">docker-ipsec-vpn-server</a></li><li><a href="https://github.com/hwdsl2/setup-ipsec-vpn/blob/master/docs/ikev2-howto-zh.md">IKEv2 VPN 配置和使用指南</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
